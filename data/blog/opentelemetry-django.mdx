---
title: Beginner's Guide to OpenTelemetry & Django (2025)
slug: opentelemetry-django
date: 2025-11-25
tags: [Observability, Python, OpenTelemetry, Monitoring]
authors: [ankit_anand, dhruv_ahuja]
description: OpenTelemetry provides an open-source standard with a consistent collection mechanism and data format. In this article, learn how to set up monitoring for a Django application using OpenTelemetry.
image: /img/blog/common/django-dashboard.webp
hide_table_of_contents: false
keywords: [opentelemetry,opentelemetry django,opentelemetry python,distributed tracing,observability,django monitoring,django instrumentation,signoz]
---

Django is a popular open-source "batteries-included" Python web framework that enables rapid development while taking out much of the hassle from routine web development. By providing pre-built components like ORM integrations, authentication/authorization systems and more, it enables developers to focus on business logic and iterate fast. As such, developers and organizations worldwide use Django to build web apps of varying complexities.

A Django application is composed of multiple interconnected components such as HTTP servers, WSGI/ASGI gateways, databases, caches, background workers and more. Due to the complexity of modern web applications, these components may misbehave at various stages of the application's lifespan. To observe a Django application (including monitoring its vitals for performance concerns), you need to observe all these components. And thatâ€™s where OpenTelemetry comes into the picture.

We will walk you through the process of implementing OpenTelemetry for Django applications by instrumenting a sample Django application to generate telemetry data, and sending the data to an OpenTelemetry-native observability backend like SigNoz to visualize and analyze. Built to work with OpenTelemetry from day 1, SigNoz is the ideal choice for handling telemetry data of all volumes.

## What is OpenTelemetry Django?

[OpenTelemetry Django](https://signoz.io/docs/instrumentation/django/) instrumentation enables the generation and management of telemetry data (logs, metrics, and traces) from your Django application. This data is then used to observe the application and gain insights into its performance and behavior. OpenTelemetry provides an open-source standard with a consistent data format and collection mechanism. As application owners, you will always have the freedom to choose different vendors to visualize the collected telemetry data, and can consume this data in a variety of formats.

Instrumentation is the biggest challenge engineering teams face when starting out with monitoring their application performance. [OpenTelemetry](https://signoz.io/why-opentelemetry/) is the leading open-source standard solving the problem of instrumentation. It is currently an incubating project under the [Cloud Native Computing Foundation](https://www.cncf.io/) and aims to make telemetry data a built-in feature of cloud-native software applications.

{/* <!-- ### Sample Django application

We will be using a sample poll application which will consist of two parts:

- A public site that lets people view polls and vote in them
- An admin site that lets you add, change and delete polls.

You can find the detailed tutorial on [official django website](https://docs.djangoproject.com/en/3.1/intro/tutorial01/).

<figure data-zoomable align='center'>
    <img src="/img/blog/2022/01/django_app_admin_panel.webp" alt=""/>
    <figcaption><i>Admin site of the sample Django application</i></figcaption>
</figure>
 --> */}

## Implementing OpenTelemetry in Django Applications

Let's go through the steps of setting up and instrumenting a Django application with OpenTelemetry to emit traces and metrics. We will start with automatic instrumentation as it is easy to setup and covers most observability needs in the beginning (traces and metrics). We will then go over manual instrumentation to enable you to extract the most value from OTel integrations in applications.
In this guide, we are going to send the emitted telemetry to SigNoz.

### Prerequisites for Application Instrumentation

There are the main prerequisites to getting started:

- A [SigNoz Cloud Account](https://signoz.io/teams/)
- Python 3.8 or later ([download the latest version here](https://www.python.org/downloads/))
- for Django, you must defineÂ `DJANGO_SETTINGS_MODULE` correctly. Since our project is called `mysite`, we set the value as following:

    ```bash
    export DJANGO_SETTINGS_MODULE=mysite.settings
    ```

### Step 1: Setting Up SigNoz

As discussed previously, we will send the applicationâ€™s emitted telemetry to SigNoz. [**SigNoz**](https://signoz.io/)Â is an OpenTelemetry-native APM that is built from the ground to process OpenTelemetry data.

<GetStartedSigNoz />

### Step 2: Preparing the Sample Django Application

We have prepared a [sample Django application](https://github.com/SigNoz/sample-django) to speed up the setup process. We'll be using the Django admin panel to create and interact with polls.

Clone the GitHub repository locally by running:

```bash
git clone https://github.com/SigNoz/sample-django.git
cd sample-django
```

Next, we will create and activate a Python virtual environment. Setting up virtual environments is a recommended practice to avoid dependency conflicts between different Python projects on your system.

```bash
# create a virtual environment with `.venv` folder name
python3 -m venv .venv
# activate the virtual environment
source .venv/bin/activate

# install all required dependencies
python -m pip install -r requirements.txt
```

Below is a brief explanation of the OpenTelemetry packages included in the `requirements.txt`:
`opentelemetry-distro` - The distro provides a mechanism to automatically configure some of the more common options for users. It helps to get started with OpenTelemetry auto-instrumentation quickly.

`opentelemetry-exporter-otlp` - This library provides a way to install all OTLP exporters. You will need an exporter to send the data to SigNoz.

<KeyPointCallout title="Debugging OTel Exporter Installation">
TheÂ `opentelemetry-exporter-otlp`Â is a convenient wrapper package to install all OTLP exporters. Currently, it installs:

- opentelemetry-exporter-otlp-proto-http
- opentelemetry-exporter-otlp-proto-grpc

- (soon) opentelemetry-exporter-otlp-json-http

The `opentelemetry-exporter-otlp-proto-grpc` package installs the gRPC exporter which depends on the `grpcio` package. The installation of `grpcio` may fail on some platforms for various reasons. If you run into such issues, or you don't want to use gRPC, you can install the HTTP exporter instead by installing the `opentelemetry-exporter-otlp-proto-http` package. You need to set the `OTEL_EXPORTER_OTLP_PROTOCOL` environment variable to `http/protobuf` to use the HTTP exporter.
</KeyPointCallout>

### Step 3: Installing OpenTelemetry Instrumentation Packages

Now, we need to install the required OTel instrumentation libraries to generate telemetry from our application.

The `opentelemetry-bootstrap` command installs the corresponding instrumentation packages for libraries present in the current environment.

```bash
opentelemetry-bootstrap --action=install
```

### Step 4: Prepare your Django Application

Django applications require some setup operations â€” database migrations, superuser creation and so on â€” before we can execute them, and the same is true here.

You need to run the following commands to prepare the Django application for usage:

a. This command is used to perform the initial database migration. You will only need to run this the very first time you deploy your app.

```bash
python3 manage.py migrate
```

b. This command is used to collect static files from multiple apps into a single path.

```bash
python3 manage.py collectstatic
```

c. The following command creates a user who can log in to the admin site. You will be asked to create a username and a password. You will need the username and password to login to the admin portal later.

```bash
python3 manage.py createsuperuser
```

The sample app creates an admin account as shown in the picture below.

<figure data-zoomable align='center'>
    <img src="/img/blog/2022/01/django_app_login.webp" alt=""/>
    <figcaption><i>You will need the username and password to log into the admin panel</i></figcaption>
</figure>

### Step 5: Instrumenting the Django Application

We're almost done. In the last step, we just need to configure a few environment variables for the [OTLP exporters](https://opentelemetry.io/docs/specs/otel/protocol/exporter/).

We will be running the app server using Gunicorn. As Gunicorn uses a pre-fork model, we have configured a `gunicorn.config.py` that ensures OpenTelemetry hooks are initialized for child workers as they spawn.

The run command will look like:

```bash
OTEL_RESOURCE_ATTRIBUTES=service.name=sample-django-app \
OTEL_EXPORTER_OTLP_ENDPOINT="https://ingest.{region}.signoz.cloud:443" \
OTEL_EXPORTER_OTLP_HEADERS="signoz-ingestion-key=<SIGNOZ_INGESTION_KEY>" \
OTEL_EXPORTER_OTLP_PROTOCOL=grpc \
opentelemetry-instrument gunicorn mysite.wsgi -c gunicorn.config.py --workers 2 --threads 2
```

You can get SigNoz ingestion key and region from your SigNoz Cloud account from Settings --> Ingestion.

<KeyPointCallout title="Self-Hosted Setup">
If you are running SigNoz in self-hosted mode, use the localhost endpoint:

 `OTEL_EXPORTER_OTLP_ENDPOINT="http://localhost:4317" \`
</KeyPointCallout>

<figure data-zoomable align='center'>
    <img src="/img/blog/2025/11/ingestion-keys-view.webp" alt="Ingestion details for your SigNoz Cloud account"/>
    <figcaption><i>Ingestion details for your SigNoz Cloud account</i></figcaption>
</figure>

After running the command, visit [http://localhost:8000/admin](http://localhost:8000/admin) to open the admin panel and validate your app is running. Generate some telemetry to be captured by adding a few questions through the app interface.

The following video guides you on how the exported application data flows through and is visualized by SigNoz:

<figure data-zoomable align='center'>
    <iframe
        className="box-shadowed-image"
        src="https://www.youtube.com/embed/bQdb6M9CWwY"
        width="100%"
        height="540"
        frameBorder="0"
        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
        allowFullScreen
    />
</figure>

### Troubleshooting

Application hot-reload can cause inconsistent data generation by breaking OTel instrumentation. Ensure you run the application without the `--reload` flag.

If you want to run the application with a docker image, refer to the section below for instructions.

### Instrument Django Application Using Docker

You can use the below instructions if you want to run your app as a Docker container, below are the instructions.

### Step 1: Build Docker Image

Build the application Docker image by running:

```bash
docker build -t sample-django-app .
```

### Step 2: Configure Environment Variables

As previously discussed, to send the collected data to SigNoz, you need to set some environment variables while running the application with OpenTelemetry. The following command will set the requisite values and start the container:

```bash
docker run -d --name django-container \
-e DJANGO_SETTINGS_MODULE=mysite.settings \
-e OTEL_RESOURCE_ATTRIBUTES='service.name=sample-django-app' \
-e OTEL_EXPORTER_OTLP_ENDPOINT="https://ingest.{region}.signoz.cloud:443" \
-e OTEL_EXPORTER_OTLP_HEADERS="signoz-ingestion-key=SIGNOZ_INGESTION_KEY" \
-e OTEL_EXPORTER_OTLP_PROTOCOL=grpc \
-p 8000:8000 sample-django-app
```

If you instead prefer a Docker Compose setup:

```bash
# If you are running SigNoz through official Docker Compose setup, run `docker network ls` and find ClickHouse network id. It will be something like- clickhouse-setup_default
# and pass network id by using --net <network ID>

docker run -d --name django-container \ 
--net clickhouse-setup_default  \ 
--link clickhouse-setup_otel-collector_1 \
- e DJANGO_SETTINGS_MODULE=mysite.settings \
-e OTEL_RESOURCE_ATTRIBUTES='service.name=sample-django-app' \
-e OTEL_EXPORTER_OTLP_ENDPOINT="https://ingest.{region}.signoz.cloud:443" \
-e OTEL_EXPORTER_OTLP_HEADERS="signoz-ingestion-key=SIGNOZ_INGESTION_KEY" \
-e OTEL_EXPORTER_OTLP_PROTOCOL=grpc \
-p 8000:8000 sample-django-app
```

## Exporting Django Logs to OpenTelemetry Backend

The fragmented and somewhat complex nature of logging system in Python, in large part due to logging having the longest legacy as a monitoring mechanism, means that logging takes more effort to setup compared to other forms of telemetry. We must manually instrument our application, and create a "bridge" between the OpenTelemetry logging framework and Python's `logging` library. Copy-paste the following code into a new file called `otel_config.py`:

```py
import os
import logging

from opentelemetry.instrumentation.logging import LoggingInstrumentor
from opentelemetry.sdk.resources import Resource
from opentelemetry._logs import set_logger_provider, get_logger_provider
from opentelemetry.sdk._logs import LoggerProvider, LoggingHandler
from opentelemetry.sdk._logs.export import BatchLogRecordProcessor, ConsoleLogExporter
from opentelemetry.exporter.otlp.proto.grpc._log_exporter import OTLPLogExporter

def setup_opentelemetry():
    logger = logging.getLogger()

    otlp_export_endpoint = os.environ["OTEL_EXPORTER_OTLP_ENDPOINT"]

    # add resource metadata to logs
    resource = Resource.create(attributes={
        "service.name": "sample-django-app"
    })
    logger_provider= LoggerProvider(resource=resource)
    set_logger_provider(logger_provider)

    # define the exporter to send logs to the observability backend 
    log_exporter = OTLPLogExporter(endpoint=otlp_export_endpoint)
    # register it with the global provider
    logger_provider.add_log_record_processor(
        BatchLogRecordProcessor(log_exporter)
    )

    # configure the python logging module to support OTel by registering the handler
    handler = LoggingHandler(level="INFO", logger_provider=logger_provider)
    logger.addHandler(handler)
    logger.setLevel(logging.INFO)

    # inject trace context into logs
    LoggingInstrumentor().instrument(set_logging_format=True)

    logger.info("OpenTelemetry logging is configured.")
```

Once done, open the `wsgi.py` file â€” as we're using Gunicorn to run the application server â€” and add the import and invocation statement just after the import statements:

```py
from otel_config import setup_opentelemetry

setup_opentelemetry()
```

This will ensure the function is invoked when Gunicorn starts, and will configure log records to be transformed into and forwarded to our [defined OTLP endpoint](#step-2-configure-environment-variables). Try it out by adding some log statements in the views, then checking the `Logs` panel.

<figure data-zoomable align='center'>
    <img src="/img/blog/2025/11/otel-django-logs.webp" alt="Application Logs in SigNoz Logs Pane"/>
    <figcaption><i>Application Logs in SigNoz Logs Pane</i></figcaption>
</figure>

Logging in Django is a vast topic, and there is much nuance to it. We have a deep-dive on this topic [available here](https://signoz.io/guides/django-logging/).

## Implementing Custom Traces and Metrics

Observability is a practice that should evolve alongside your applications, and part of the process is manually instrumenting key areas of the codebase that are otherwise unobserved. Having custom traces and metrics will help you capture details that matter to your application systems, deliver business value, and recognize and resolve complex issues faster.

You can find more information on manual instrumentation in Python in [this section](https://signoz.io/opentelemetry/python/#capturing-custom-traces-for-application-specific-flows) of our OTel Python blog.

## OpenTelemetry vs Other Django Monitoring Solutions

When it comes to observability for Django applications, OpenTelemetry offers several advantages over other solutions. Let's compare OpenTelemetry with some popular alternatives:

### 1. OpenTelemetry vs Django Debug Toolbar

**Django Debug Toolbar:**
- Pros: Easy to set up, provides detailed information about queries, templates, and HTTP headers.
- Cons: Only works in development, not suitable for production monitoring.

**OpenTelemetry:**
- Pros: Works in both development and production, provides [distributed tracing](https://signoz.io/distributed-tracing/), more comprehensive data collection.
- Cons: Requires more initial setup.

### 2. OpenTelemetry vs New Relic

**New Relic:**
- Pros: Comprehensive APM solution, easy to set up with Django.
- Cons: Proprietary solution, can be expensive for large-scale applications.

**OpenTelemetry:**
- Pros: Open-source, vendor-agnostic, more flexible and customizable.
- Cons: Requires more configuration and a separate backend for data storage and visualization.

### 3. OpenTelemetry vs Sentry

**Sentry:**
- Pros: Excellent for error tracking and crash reporting.
- Cons: Limited in terms of performance monitoring and distributed tracing.

**OpenTelemetry:**
- Pros: Provides both error tracking and performance monitoring, supports distributed tracing.
- Cons: May require additional setup for error tracking features.

### 4. OpenTelemetry vs Datadog

**Datadog:**
- Pros: Comprehensive monitoring solution with wide integration support.
- Cons: Can be expensive, proprietary solution.

**OpenTelemetry:**
- Pros: Open-source, more cost-effective for large-scale deployments, vendor-agnostic.
- Cons: Requires more initial setup and configuration.

### Key Advantages of OpenTelemetry:

1. **Vendor Agnostic:** OpenTelemetry allows you to switch between different backends without changing your instrumentation code.

2. **Comprehensive Data Collection:** Collects traces, metrics, and logs in a standardized format.

3. **Community-Driven:** Being open-source, it benefits from community contributions and rapid improvements.

4. **Future-Proof:** As an emerging standard backed by major tech companies, it's likely to have long-term support and development.

5. **Flexibility:** Can be used with various languages and frameworks beyond Django.

6. **Cost-Effective:** Open-source nature makes it more cost-effective for large-scale deployments.

While OpenTelemetry requires more initial setup compared to some out-of-the-box solutions, its flexibility, comprehensive data collection, and vendor-agnostic nature make it an excellent choice for Django applications, especially those looking for a scalable, future-proof observability solution.

## Conclusion

OpenTelemetry makes it very convenient to instrument your Django application. You can then use an open-source APM tool like SigNoz to analyze the performance of your app. As SigNoz covers the three pillars of observability â€” traces, metrics, and logs â€” under one pane, you avoid the contextual overhead of maintaining separate tools.

SigNoz Cloud enables first-class OpenTelemetry support with guided installation steps for instrumenting all parts of your tech stack, including infrastructure, and supports 50+ data sources. [Sign up today](https://signoz.io/teams/) to get unlimited access to all features for 30 days.

## FAQs

### What is OpenTelemetry Django?
OpenTelemetry Django instrumentation enables the generation of telemetry data from your Django application. This data is then used to monitor the performance of Django applications. OpenTelemetry provides an open-source standard with a consistent collection mechanism and data format.

### Why should I use OpenTelemetry for monitoring my Django application?
OpenTelemetry is vendor-agnostic and provides a standardized way to instrument your Django application. It allows you to collect telemetry data (logs, metrics, and traces) which can be exported to various backends. This flexibility ensures that you're not locked into a specific monitoring solution.

### How do I set up OpenTelemetry instrumentation for my Django application?
To set up OpenTelemetry instrumentation for Django:
1. Install necessary packages ([opentelemetry-distro](https://signoz.io/opentelemetry/python-auto-instrumentation/), opentelemetry-exporter-otlp)
2. Configure environment variables for the OTLP exporter
3. Use the opentelemetry-instrument command to run your Django application
4. Choose a backend (like SigNoz) to visualize and analyze the collected data

### Can I use OpenTelemetry with Docker for my Django application?
Yes, you can use OpenTelemetry with Docker for your Django application. You'll need to build a Docker image of your app, set the necessary environment variables for OpenTelemetry, and run the container with these variables. The article provides specific instructions for this setup.

### What kind of metrics can I monitor with OpenTelemetry for Django?
With OpenTelemetry, you can monitor various metrics for your Django application, including:
- Request rate
- Error rate
- Request duration (latency)
- Database query performance
- External service calls
- Custom metrics specific to your application logic

### How does OpenTelemetry Django instrumentation affect my application's performance?
OpenTelemetry is designed to have minimal impact on application performance. However, as with any instrumentation, there may be a slight overhead. The benefits of comprehensive monitoring and troubleshooting capabilities usually outweigh this minimal performance impact.

---

Some more blogs we think youâ€™ll like ðŸ‘‡

[Django Logging - Complete Guide to Python Django Logging](https://signoz.io/guides/django-logging/)

[Golang Aplication Monitoring with OpenTelemetry and SigNoz](https://signoz.io/opentelemetry/go/)

[OpenTelemetry Collector from A to Z: A Production-Ready Guide](https://signoz.io/blog/opentelemetry-collector-complete-guide/)
